(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
let underscore = angular.module('Underscore', []).factory('_', () => {
    return window._;
});

/**
 * 'jQueryScrollbar' and 'googlechart' are ready-made modules which I added to the application
 * 'Underscore' is the module name for the real underscore ('_') library, I loaded it as a module which I can then inject
 * it like any other dependency
 * @type {angular.Module}
 */
let application = angular.module('ContactBook', ['ngRoute', 'jQueryScrollbar', 'Underscore', 'googlechart']);
application.directive('contact', [() => {
    return {
        restrict: 'E',
        replace: true,
        template: '<a ng-href="#/info/{{ contact.id }}"><span class="glyphicon"></span> <span ng-bind="contact.firstname"></span> <span ng-bind="contact.lastname"></span></a>'
    };
}]);
application.factory('ContactFactory', ['$http', 'FilterHandlerFactory', ($http, FilterHandlerFactory) => {
    const API_URL = 'http://localhost:3000/api/contacts';

    const $RESULTS = {
        limit: 100,
        count: 0,
        pages: 1,
        searchterm: ''

        // Will hold the filters like page, letter, order by, etc..
    };let $filters = {};

    /**
     * Used to update the results every time we call a new information from the server
     * @param results
     */
    function flush(results) {
        $RESULTS.count = results.count;
        $RESULTS.pages = Math.ceil(results.count / $RESULTS.limit);
    }

    return {
        results: function () {
            return $RESULTS;
        },

        setFilters: function (filters) {
            $filters = filters;
            return this;
        },

        fetchContacts: function () {
            // Build the query string for filters
            let queryString = FilterHandlerFactory.toQueryString($filters);
            // Check if letter or all

            let uri = '';
            switch ($filters.mode) {
                case 'alphabet':
                    uri = `${API_URL}/letter/${$filters.letter}/?${queryString}`;
                    break;

                case 'all':
                    uri = `${API_URL}/?${queryString}`;
                    break;

                case 'search':
                    uri = `${API_URL}/search/${$filters.searchterm}/?${queryString}`;
                    break;
            }

            return FilterHandlerFactory.pipeRequest($http.get(uri), results => flush(results));
        },

        // One single contact
        fetchOne: function (contact_id) {
            return $http.get(API_URL + '/' + contact_id);
        },

        // Search results
        search: function (term, page = 1) {
            return FilterHandlerFactory.pipeRequest($http.get(API_URL + '/search/' + term + '?page=' + page), results => {
                flush(results);
            });
        },

        create: function (contact) {
            return FilterHandlerFactory.pipeRequest($http({
                method: 'POST',
                url: API_URL + '/',
                data: JSON.stringify(contact),
                headers: { 'Content-Type': 'application/json' }
            }), contact_id => {
                flush({ count: $RESULTS.count + 1 });
            });
        },

        destroy: function (contact_id) {
            return FilterHandlerFactory.pipeRequest($http.delete(API_URL + '/' + contact_id), result => {
                flush({ count: $RESULTS.count - 1 });
            });
        },

        insights: function () {
            return $http.get(API_URL + '/insights');
        }
    };
}]);
application.controller('ContactInfoController', ['$scope', '$routeParams', 'ContactFactory', '$location', ($scope, $routeParams, ContactFactory, $location) => {
    let contact_id = $routeParams.contact_id;

    ContactFactory.fetchOne(contact_id).then(contact => {
        $scope.currentContact = contact.data;
    });

    // Remove contact from list
    $scope.removeContact = contact => {
        ContactFactory.destroy(contact.id).then(contact_id => {
            let index = $scope.contacts.indexOf(contact);
            let letter = contact.firstname.substring(0, 1);
            $scope.contacts.splice(index, 1);
            $scope.setFilter(['searchterm'], ['']);
            $location.path(`/alphabet/${$scope.filter.letter}/${$scope.filter.page}`);
        });
    };
}]);
/**
 * In this Controller is making use of 'googlechart' module and template (_insights.html) making use
 * of the directives in the module 'google-chart', and 'chart' attributes
 * You can see the module here: https://angular-google-chart.github.io/angular-google-chart
 *
 * I've created a route especially for the insights (see 'routes/contact.js') to collect interesting data:
 *  - The main domains for the emails
 *  - The main states of the contacts
 */
application.controller('InsightsController', ['$scope', '$routeParams', 'ContactFactory', ($scope, $routeParams, ContactFactory) => {
    $scope.insights = {
        domains: [],
        states: []
    };

    $scope.charts = {
        states: {
            type: "GeoChart",
            data: [['State', 'Contacts']],
            options: {
                region: 'US',
                displayMode: 'regions',
                resolution: 'provinces',
                width: 500,
                height: 375
            },

            formatters: {
                number: [{
                    columnNum: 1
                }]
            }
        },

        domains: {
            type: "PieChart",
            data: [['Domain', 'Contacts']],
            options: {
                width: 500,
                height: 375
            }
        }
    };

    ContactFactory.insights().then(insights => {
        let domains = $scope.insights.domains = insights.data.domains;
        let states = $scope.insights.states = insights.data.states;

        states.forEach(val => {
            $scope.charts.states.data.push([val.state, val.count]);
        });

        domains.forEach(val => {
            $scope.charts.domains.data.push([val.domain, val.count]);
        });
    });
}]);
application.config(function ($routeProvider) {
    $routeProvider.when('/add', {
        templateUrl: './application/Contact/Add/_add-contact.html',
        controller: 'AddContactController'
    }).when('/insights', {
        templateUrl: './application/Insights/_insights.html',
        controller: 'InsightsController'
    }).when('/info/:contact_id', {
        templateUrl: './application/Contact/_contact.html',
        controller: 'ContactInfoController'
    }).when('/all', {
        templateUrl: './application/Shared/_home.html'
    }).when('/alphabet/:letter', {
        templateUrl: './application/Shared/_home.html'
    }).otherwise({
        redirectTo: '/all'
    });
});
application.factory('FilterHandlerFactory', ['$q', '_', ($q, _) => {
    return {
        pipeRequest: function (request, fn) {
            let deferred = $q.defer();

            request.then(response => {
                if (response.status === 204) {
                    fn(null);
                    deferred.resolve(null);
                } else {
                    fn(response.data);
                    deferred.resolve(response.data);
                }
            });

            return deferred.promise;
        },

        toQueryString: function (obj) {
            return _.map(obj, (v, k) => {
                return encodeURIComponent(k) + '=' + encodeURIComponent(v);
            }).join('&');
        }
    };
}]);
application.controller('MainController', ['$scope', '$location', '$route', '$routeParams', 'ContactFactory', ($scope, $location, $route, $routeParams, ContactFactory) => {
    $scope.letterArray = [];
    $scope.contacts = [];
    $scope.ready = false;

    // Will hold the page number and current letter
    $scope.filter = {
        page: 1,
        letter: 'A',
        order: 'asc',
        mode: 'all',
        by: 'firstname',
        searchterm: null

        // Have to fill in the array with the english alphabet
    };for (let i = 0; i < 26; i++) $scope.letterArray.push(String.fromCharCode(65 + i));

    // Insert it to the filter of the results
    $scope.setContactsList = function () {
        ContactFactory.setFilters($scope.filter).fetchContacts().then(contacts => $scope.contacts = contacts.contacts);
    };

    // Setting new filters
    $scope.setFilter = function (names, values) {
        angular.forEach(names, (name, index) => $scope.filter[name] = values[index]);
    };

    /**
     * Watch Collection function for the filter properties
     * Each time the filters is being updated we are firing new request
     */
    $scope.$watchCollection('filter', (newValue, oldValue) => {
        $scope.setContactsList();
    });

    // When route changes, fire the functions we need
    $scope.$on('$routeChangeStart', (next, current) => {
        // No other routes other than /<LETTER>/PAGE
        let path = $location.path();
        let isAlphabet = /^\/alphabet\/[A-Z]/.test(path);

        if (isAlphabet === true || /^\/all/.test(path) === true) {
            /*
             * If the user came from outside the application (http://localhost:3000/#/alphabet/C/4) for example
             * change the mode to be 'alphabet' cause the default is 'all'
             */
            if (isAlphabet) $scope.setFilter(['mode', 'letter', 'page'], ['alphabet', current.pathParams.letter || 'A', current.pathParams.page || 1]);
        }
    });

    // Wait till document is ready to remove loader
    angular.element(document).ready(() => $scope.ready = true);
    $scope.$watch('ready', (newValue, oldValue) => angular.element(document.getElementById('main')).removeClass('loading'));
}]);
application.controller('PaginationController', ['$scope', '_', 'ContactFactory', ($scope, _, ContactFactory) => {
    // Get the results object from the factory
    $scope.results = ContactFactory.results();
    $scope.pages = [];

    /**
     * Using this function in order to enable the ng-repeat (inside 'PaginationController') to iterate
     * through the pages
     * @param pages
     * @returns {Array}
     */
    $scope.getPages = pages => {
        return new Array(pages);
    };

    $scope.page = page => $scope.filter.page = page;
}]);
application.controller('SearchController', ['$scope', '$location', ($scope, $location) => {
    $scope.$watch('filter.searchterm', (newVal, oldVal) => {
        if (oldVal == null && newVal == null) return;

        if (newVal.length < 2) {
            // When user deleted ALL the input, reset search
            if (newVal.length === 0) $scope.setFilter(['mode', 'page'], ['all', 1]);

            return;
        }

        $scope.filter.mode = 'search';
    });

    $scope.reset = function () {
        console.log('reset');
        $scope.setFilter(['mode', 'page'], ['all', 1]);
    };
}]);
/**
 * This directive is in charge on the search functionality
 * It uses '_.debounce', preventing server spamming while the user is typing
 * It uses two way bindings, affecting the parent scope with the new contacts
 * The directive is being added as an attribute to the search input, keeps the separation between
 * DOM and logic
 */

application.directive('searchable', ['ContactFactory', ContactFactory => {
    return {
        restrict: 'A',
        link: (scope, element, attrs) => {
            scope.setFilter(['mode'], ['all']);
            element.on('keyup', _.debounce(e => {
                let term = element[0].value;

                // Don't allow less than 2 letters, one letter is too much
                if (term.length < 2) {
                    // When user deleted ALL the input, reset search
                    if (term.length === 0) scope.reset();

                    return false;
                }
            }, 300));
        }
    };
}]);
application.controller('AddContactController', ['$scope', '$location', 'ContactFactory', ($scope, $location, ContactFactory) => {
    $scope.proccessing = false;
    $scope.path = $location.path();

    $scope.addContact = () => {
        let contactDetails = $scope.currentContact;
        $scope.proccessing = true;

        ContactFactory.create(contactDetails).then(contact => {
            $scope.proccessing = false;
            let letter = $scope.currentContact.firstname.substring(0, 1);

            let contact_id = $scope.currentContact.id = contact.contact_id;
            $scope.contacts.push($scope.currentContact);
            $scope.currentContact = {};

            $scope.setFilter(['mode', 'letter'], ['alphabet', letter]);
            $location.path(`info/${contact_id}`);
        });
    };

    $scope.submitForm = function (event, isValid) {
        event.preventDefault();
        if (isValid) $scope.addContact();

        return false;
    };
}]);
application.directive('googleplace', () => {
    return {
        require: 'ngModel',
        link: (scope, element, attrs, model) => {
            let options = {
                types: [],
                componentRestrictions: {
                    country: "US"
                }
            };

            scope.gPlace = new google.maps.places.Autocomplete(element[0], options);

            google.maps.event.addListener(scope.gPlace, 'place_changed', place => {
                scope.$apply(() => {
                    model.$setViewValue(element.val());
                });
            });
        }
    };
});

},{}]},{},[1]);
